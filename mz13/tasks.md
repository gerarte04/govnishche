### Problem mz13-1: mz13-1

Напишите программу. Родитель создает сына, тот — внука, а тот — правнука. Правнук передает в канал текущее время, полученное с помощью системного вызова ```time```, в бинарном виде (тип ```time_t```).

Отец, сын и внук считывают время из канала. Процесс-отец выводит на экран строку "Y:????", где ???? заменяются на текущий год, сын — "M:??", где ?? заменяются на текущий месяц в году (от 1 до 12), число всегда выводится с двумя знаками, внук — "D:??", где ?? заменяются на номер дня в месяце, всегда выводящееся с двумя знаками.

Внук должен вывести число первым, сын — вторым, а отец — третьим. Записывать в канал разрешается только правнуку. Родитель должен дождаться завершения всех процессов и завершиться сам с кодом 0.

Пример вывода:

```
D:11
M:09
Y:2001
```

### Problem mz13-2: mz13-2

Процесс-родитель создает процесса-сына, а тот в свою очеред процесса-внука. Процесс-родитель и процесс-внук должны быть соединены анонимным каналом в направлении от родителя к внуку.

Процесс-родитель считывает 32-битные знаковые целые числа, подаваемые на стандартном потоке ввода в текстовом виде. Последовательность заканчивается признаком конца файла. Процесс-родитель передает считанные числа в канал в бинарном виде.

Процесс-внук считывает числа из канала и вычисляет их сумму. После чтения всех чисел процесс-внук выводит на стандартный поток вывода их сумму и завершает работу.

Процесс-родитель должен дождаться завершения всех порожденных им процессов и завершиться сам с кодом завершения 0.

Ошибка "Synchronization error" означает, что родитель завершился раньше какого-либо из порожденных им процессов.

_Examples_

**Input**

```
1 2 3 4 5 6 7 8 9 10
```

**Output**

```
55
```

### Problem mz13-3: mz13-3

Программе в аргументах командной строки передаются три команды для выполнения, затем два имени файла (всего 5 аргументов командной строки). Программа должна запустить на выполнение процессы, чтобы они выполнялись в конфигурации, соответствующей команде shell:

```
( cmd1 < file1 && cmd2 ) | cmd3 >> file2
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить выполнение.

Считайте, что команды ```cmd1```, ```cmd2```, ```cmd3``` можно запускать на выполнение с помощью ```execlp```.

Запись ```CMD1 && CMD2``` означает, что процесс ```CMD2``` должен быть запущен только после успешного завершения процесса ```CMD1```.

Запись ```( CMD )``` используется для группировки, при этом вся командная строка CMD выполняется в отдельном процессе, порожденном основным процессом.


### Problem mz13-4: mz13-4

Программе в аргументах командной строки передается произвольное (возможно пустое) количество команд для выполнения. Программа должна запустить на выполнение процессы, чтобы они выполнялись в конфигурации, соответствующей команде shell:

```
cmd1 | cmd2 | ... | cmdN
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить выполнение. Если все системные вызовы, исполнявшиеся родителем (например, создание процесса), завершились успешно, родитель завершается с кодом 0. В случае ошибки выполнения системного вызова (например, невозможности создания очередного процесса), родитель уничтожает уже созданные к этому моменту процессы с помощью сигнала ```SIGKILL``` и сам завершается с кодом 1 после завершения сыновей.

Команды ```cmd1```, ```cmd2```, ... запускайте на выполнение с помощью ```execlp```.

В родителе одновременно может быть открыто не более 6 файловых дескрипторов.

Создаваемые процессы должны оставаться в группе процессов родителя.

Программа не должна ничего выводить на стандартный поток ошибок.

Например, если скомпилированная программа называется solution, то ее запуск с аргументами

```
./solution ls cat wc
```

должен дать такой же результат на стандартном потоке вывода, как выполнение команды shell

```
ls | cat | wc
```

### Problem mz13-5: mz13-5

Родитель создает двух сыновей, связывая их двумя каналами. Сыновья начинают обмениваться числами 1, 2, 3, ... Число 1 получает первый сын. При получении числа из входного канала каждый сын печатает на стандартный поток вывода родителя свой номер (1 или 2) и полученное число и пересылает обратно число, на 1 большее. При достижении числа, задаваемого в командной строке, сын не пересылает число в канал, а завершает работу.

Процесс может завершить работу либо при получении максимального числа из канала, либо при наступлении конца файла в канале. Завершать процесс в других случаях не разрешается.

Отец дожидается завершения работы обоих процессов, затем выводит строку Done и завершает работу.

Если в командной строке передано число 5, pid первого процесса - 100, pid второго процесса - 101, то вывод должен быть таким:

```
1 1
2 2
1 3
2 4
Done
```

Данные передавать в pipe в текстовом виде, для ввода-вывода использовать высокоуровневый ввод-вывод (```printf```, ```scanf``` и т. д.).

Привязывать файловые дескрипторы к дескрипторам потока можно либо с помощью функции ```fdopen```, либо с помощью перенаправления стандартных потоков ввода-вывода.
