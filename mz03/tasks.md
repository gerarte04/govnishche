### Problem mz03-1: mz03-1

Напишите функцию ```bit_reverse``` со следующим прототипом на Си:

```
STYPE bit_reverse(STYPE value);
```

Где ```STYPE``` — это некоторый целый знаковый тип. Кроме того, определен тип ```UTYPE``` — это некоторый целый беззнаковый тип того же размера, что и ```STYPE```.

Функция меняет порядок бит в числе на противоположный. Например, рассмотрим 4-битное целое число 0101. Поменяв порядок бит на противоположный, получим число 1010. Однако, если то же число рассматривать как 8-битное, обратный порядок бит будет равен 10100000.

Отрицательные числа представляются в дополнительном коде.

В решении запрещается использовать константы и константные выражения, дающие в качестве результата битность типа, например, ```32```, ```sizeof (value) * CHAR_BIT``` и аналогичные.

Для того, чтобы определить типы ```STYPE``` и ```UTYPE``` в своей программе для тестирования, можно использовать ```typedef``` следующим образом:

```c
typedef int STYPE;
typedef unsigned int UTYPE;
```

Сдаваемый на проверку текст должен содержать только функцию ```bit_reverse```. Определения типов ```STYPE``` и ```UTYPE``` и функция ```main``` в нем находиться не должны.

### Problem mz03-2: mz03-2

В аргументах командной строки задаются 32-битные знаковые целые десятичные числа.

На стандартный поток вывода напечатайте два числа: сначала сумму положительных аргументов командной строки, затем сумму отрицательных аргументов командной строки. Если чисел соответствующей категории нет, выводите 0.

При обработке аргументов командной строки должны проверяться все типы возможных ошибок, как, например, описано [здесь](https://github.com/blackav/cmc-os/tree/master/2021-2022/sem02).

Пример запуска программы:

```
./solution 1 -3 5 -7 +12
```

Результат выполнения программы:

```
18
-10
```

Не забывайте выводить символ перехода на новую строку в конце вывода!

### Problem mz03-3: mz03-3

В аргументах командной строки задаются вещественные числа:

* Начальный курс некоторой валюты.
* Изменения к курсу в процентах за один день. (ноль или более раз).

Курс валюты задается с четырьмя дробными цифрами, например, 69.5634. Изменения к курсу задаются в процентах и могут быть как положительными, так и отрицательными. Например, изменение курса -10.0 означает, что за день валюта подешевела на 10%, то есть, если в начале дня курс был 100.0000, то в конце дня он окажется 90.0000. Курс валюты в конце дня фиксируется с четырмя цифрами дробной части округлением по математическим правилам, все цифры дробной части после четвертой после округления отбрасываются.

Гарантируется, что ежедневные изменения курса больше -100 и меньше 100. Изменения курса задаются не более чем с четырьмя знаками дробной части. Курс валюты — положительный и не превосходит 10000 за все время.

На стандартный поток вывода напечатайте курс валюты в конце последнего дня, заданного в командной строке. Курс печатайте с четырьмя знаками дробной части.

Пример запуска программы:

```
./solution 100.0 -10.0 -5.5 1.0
```

Результат выполнения программы:

```
85.9005
```

Не забывайте выводить символ перехода на новую строку в конце вывода!

### Problem mz03-4: mz03-4

Напишите функцию

```c
int satsum(int v1, int v2);
```

которая выполняет сложение с насыщением двух знаковых чисел. То есть, если результат сложения не представим типом результата, результатом в зависимости от знака будет либо минимальное, либо максимальное число, представимое типом результата. Например, если складываются с насыщением два четырехбитных числа (диапазон представимых чисел [−8;7]): 5 + 5 => 7, −4 + −6 => −8.

Тип ```int``` имеет размер 32 бита. Отрицательные числа представляются в дополнительном коде.

В функции должны быть объявлены две константы:

```c
enum { MY_INT_MAX = ... };  // максимальное значение знакового 32-битного типа
enum { MY_INT_MIN = ... };  // минимальное значение знакового 32-битного типа
```

Разрешается использовать только 32-битные целые типы. Разрешается использовать только константу 0. Разрешается использовать только стандартные средства языка Си (расширения gcc использовать запрещено). Константы из стандартной библиотеки (```INT_MAX``` и аналогичные) также использовать запрещено.

### Problem mz03-5: mz03-5

Элемент списка определяется следующим образом:

```c
struct Elem
{
    struct Elem *next;
    char *str;
};
```

```str``` указывает на строку, размещенную в области динамической памяти.

Напишите функцию на Си:

```c
struct Elem *dup_elem(struct Elem *head);
```

Если у некоторого элемента ```p``` в строке ```p->str``` записано текстовое десятичное представление 32-битного целого числа ```x```, причем пробелы в начале допускаются, а в конце - нет, то перед каждым таким элементом в список добавляется новый элемент, у которого в строке записано десятичное представление числа ```x + 1```, если оно представимо 32-битным целым знаковым значением. В текстовом представлении числа в новом элементе списка не должно быть пробелов, лишних знаков плюс и нулей.

Функция должна вернуть указатель на первый элемент получившегося списка.

Например, если в списке хранились строки "10" "5x" "alpha" " -03", то в результирующем списке должны храниться строки "11" "10" "5x" "alpha" "-2" " -03".

В сдаваемой на проверку программе должно присутствовать определение структуры ```struct Elem```.
