### Problem ht09-3: ht09-3

Реализуйте функцию

```c
uint8_t compute_crc8(uint8_t *data, size_t size);
```

Функция должна вычислить контрольную сумму области памяти ```data``` размером ```size```.

Для вычисления должен использоваться алгоритм [cyclic redundancy check 8](http://www.sunshine2k.de/articles/coding/crc/understanding_crc.html). В статье по ссылке приведен код функции на C#, адаптируйте его к C. Используйте табличный вариант функции.

### Problem ht09-4: ht09-4

Реализуйте функции

```c
char *b64u_encode(const uint8_t *data, size_t size);
bool b64u_decode(const char *str, uint8_t **p_data, size_t *p_size);
```

Функции выполняют кодирование и декодирование массива байт в формат URL-encoded unpadded Base64 (см. [URL-encoded unpadded base64](https://en.wikipedia.org/wiki/Base64), раздел "Variants summary table" в строке base64url).

Функция ```b64u_encode``` принимает в качестве параметров указатель ```data``` на массив байт размера ```size```. Функция возвращает указатель на строку, выделенную в куче. Строка должна содержать закодированное представление входного массива байт. В закодированной строке не допускаются никакие посторонние символы, кроме кодирующих (то есть пробельные символы не допускаются). В случае ошибки выделения памяти функция возвращает ```NULL```.

Функция ```b64u_decode``` принимает в качестве входного параметра ```str``` закодированные данные в си-строке. Строка может содержать пробельные символы (см. функцию ```isspace```), которые должны игнорироваться. Функция возвращает ```false```, если входная строка содержит некорректные данные. Функция возвращает ```true```, если входные данные корректны. В этом случае по указателю ```p_data``` записывается адрес начала буфера с декодированными данными, а по указателю ```p_size``` — размер декодированных данных. В конец декодированных данных, то есть по индексу ```*p_size```, обязательно записывается нулевой байт. Память выделяется в куче.

Вы можете адаптировать какую-либо из существующих реализаций кодирования base64 при условии ссылки на первоначальную реализацию.

### Problem ht09-5: ht09-5

Реализуйте функции

```c
size_t uleb128_len(uint64_t value);
uint8_t *uleb128_encode(uint8_t *ptr, uint64_t value);

struct ReadContext
{
    uint8_t *buf;
    size_t size;
    size_t pos;
    uint64_t value_u64;
};

bool uleb128_decode(struct ReadContext *cntx);
```

Функция ```uleb128_len``` возвращает количество байт, которые необходимы для кодирования значения ```value``` в формате ULEB128.

Функция ```uleb128_encode``` кодирует переданное значение ```value``` в ULEB128 и записывает результат по адресу ```ptr```. Возвращается новое значение указателя ```ptr```, то есть возвращаемое значение указывает на место, непосредственно после конца закодированного числа. Предполагается, что память под кодирование уже выделена, и функция сама не выделяет память. Число должно кодироваться последовательностью байт минимальной длины, то есть незначащие нули в старших битах числа не допускаются, если это только не самый последний байт записи числа.

Функция ```uleb128_decode``` декодирует значение из формата ULEB128 в хост-представление числа. В случае ошибки декодирования возвращается результат ```false```, и поля структуры ```cntx``` не меняются. В случае успешного декодирования возвращается результат ```true```, и поля структуры ```cntx``` соответственно изменяются.

Данные для декодирования хранятся в буфере с адресом начала ```cntx->buf``` и размером ```cntx->size```. Декодирование должно начинаться со смещения ```cntx->pos``` в этом буфере. При успешном декодировании результат записывается в ```cntx->value_u64```, а смещение ```cntx->pos``` продвигается вперед на соответствующее число байт. Обратите внимание, что при успешном декодировании смещение не может превышать размер буфера.

При декодировании должны выявляться следующие ошибки:

* число закодировано последовательностью байтов не минимальной длины;
* закодировано число, не представимое в типе ```uint64_t```;
* запись числа выходит за границу буфера.
