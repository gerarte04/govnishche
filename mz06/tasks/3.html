<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<title>Problem statement</title>
</head>
<body>
<h3>Problem mz06-3: mz06-3</h3>

<p/>

<p>Дана структура <tt>s1</tt>:</p>

<pre>struct s1 {
    char f1;
    long long f2;
    char f3;
};</pre>

<p>Опишите структуру <tt>s2</tt>, которая бы содержала поля с именами
<tt>f1</tt>, <tt>f2</tt>, <tt>f3</tt> тех же самых типов, что и в
<tt>struct s1</tt>, но имела бы минимальный возможный размер
(за счет выравниваний).</p>

<p>Напишите функцию <tt>compactify</tt> с прототипом:</p>

<pre>size_t compactify(void *ptr, size_t size);</pre>

<p>Функции на вход подаётся указатель <tt>ptr</tt> на область
памяти размера <tt>size</tt> байт. В этой области памяти находится
массив структур <tt>struct s1</tt>, полностью заполняющий область
памяти. Уплотните этот массив за счет замены типа каждого элемента
массива с <tt>struct s1</tt> на <tt>struct s2</tt> с сохранением
значения всех элементов. В итоге должен получиться
массив из элементов типа <tt>struct s2</tt> с тем же
самым количеством элементов, начинающийся
по указателю <tt>ptr</tt>. Он будет иметь размер <tt>size2</tt>, меньший <tt>size</tt> (за счет того, что меньше памяти потеряно на выравнивания).
Функция <tt>compactify</tt> должна вернуть новый размер <tt>size2</tt>.</p>

<p>Гарантируется, что параметр size кратен размеру <tt>struct s1</tt>,
size может быть равен 0. Если size &gt; 0, то указатель <tt>ptr</tt>
не NULL.</p>

<p>В качестве решения сдайте описания структур <tt>s1</tt>, <tt>s2</tt> и
код функции <tt>compactify</tt>.</p>

    
</body>
</html>
