### Problem mz06-1: mz06-1

В аргументах командной строки задается путь к каталогу.

На стандартный поток вывода напечатайте количество файлов в заданном каталоге (без подкаталогов), удовлетворяющих следующему условию:

* Файл регулярный.
* Файл доступен на выполнение текущему пользователю.
* Его имя заканчивается на суффикс .exe.

Символические ссылки прослеживайте до соответствующих файлов (используйте соответствующий системный вызов семейства ```*stat```).

Не используйте системные вызовы, меняющие текущий каталог процесса.

### Problem mz06-2: mz06-2

Напишите функцию:

```
void normalize_path(char *buf);
```

Функция принимает на вход строку абсолютного пути. Строка всегда начинается с символа '/', в строке не встречаются несколько символов '/' подряд.

Если входная строка не равна "/" и оканчивается на '/', то этот символ с конца должен быть удален.

В строке-пути должны быть удалены все вхождения каталогов . и .. исходя из того, что каталог . — это переход на текущий каталог, а каталог .. — это переход на родительский каталог.

Функция модифицирует область памяти, в которой находится входная строка. Функция должна обрабатывать пути произвольной длины, не обязательно ограниченной константой ```PATH_MAX```.

Запрещается использовать стандартные функции.

**Examples**

_Input 1_

```
/a/b/c/
```

_Output 1_

```
/a/b/c
```

_Input 2_

```
/a/b/../
```

_Output 2_

```
/a
```

_Input 3_

```
/a/b/../../..
```

_Output 3_

```
/
```

### Problem mz06-3: mz06-3

Дана структура ```s1```:

```
struct s1 {
    char f1;
    long long f2;
    char f3;
};
```

Опишите структуру ```s2```, которая бы содержала поля с именами ```f1```, ```f2```, ```f3``` тех же самых типов, что и в ```struct s1```, но имела бы минимальный возможный размер (за счет выравниваний).

Напишите функцию ```compactify``` с прототипом:

```
size_t compactify(void *ptr, size_t size);
```

Функции на вход подаётся указатель ```ptr``` на область памяти размера ```size``` байт. В этой области памяти находится массив структур ```struct s1```, полностью заполняющий область памяти. Уплотните этот массив за счет замены типа каждого элемента массива с ```struct s1``` на ```struct s2``` с сохранением значения всех элементов. В итоге должен получиться массив из элементов типа ```struct s2``` с тем же самым количеством элементов, начинающийся по указателю ```ptr```. Он будет иметь размер ```size2```, меньший ```size``` (за счет того, что меньше памяти потеряно на выравнивания). Функция ```compactify``` должна вернуть новый размер ```size2```.

Гарантируется, что параметр ```size``` кратен размеру ```struct s1```, ```size``` может быть равен 0. Если ```size``` > 0, то указатель ```ptr``` не ```NULL```.

В качестве решения сдайте описания структур ```s1```, ```s2``` и код функции ```compactify```.

### Problem mz06-4: mz06-4

В аргументе командной строки передается путь к каталогу D и максимальный размер Z.

На стандартный поток вывода напечатайте относительные пути к регулярным файлам, которые доступны на чтение текущему пользователю и имеют размер не больше Z. Подкаталоги обрабатывайте рекурсивно на глубину не более 4. Каждый путь выводите на отдельной строке. Относительные пути не должны содержать каталогов ```.``` и ```..```

Символические ссылки игнорируйте.

Глубиной 1 считается каталог, заданный в аргументах командной строки. Относительный путь к файлу на глубине 4 запишется в виде ```a/b/c/d``` Это - максимальная глубина, которая должна обрабатываться.

Не используйте ```scandir```, ```ftw``` и аналогичные функции. Не используйте ```chdir```, ```fchdir```, ```telldir```, ```seekdir```, а также ```getpwd``` и аналогичные. Можно использовать ```opendir```, ```readdir```, ```closedir```, ```access``` и ```*stat```.

Например,

```
a
b/c
d/e/f/g
```

### Problem mz06-5: mz06-5

Напишите функцию:

```
ssize_t getcwd2(int fd, char *buf, size_t size);
```

Параметр ```fd``` — это открытый файловый дескриптор каталога, ```buf``` — адрес начала буфера в памяти, ```size``` — размер буфера.

Функция должна восстановить полный путь к каталогу, который открыт и связан с файловым дескриптором ```fd```. То есть, если ```fd``` — корневой каталог, то полный путь к каталогу — "/". Если ```fd``` — не корневой каталог, то полный путь к этому каталогу начинается с "/", состоит из записей в соответствующих каталогах, являющихся каталогами, но не символическими ссылками. На конце полного пути "/" должен отсутствовать. Например, "/usr/local/bin" (без кавычек).

Если при выполнении функции не возникло ошибок при выполнении системных вызовов и библиотечных функций, функция ```getcwd2``` должна вернуть длину строки — полного пути к каталогу (без учета ```\0```). В противном случае функция должна вернуть отрицательное значение.

Если параметр ```size``` равен 0, то функция должна вернуть только длину пути и больше не выполнять никаких действий (не модифицировать память по указателю ```buf```). Если ```size``` больше нуля, то по адресу ```buf``` должен быть записан восстановленный полный путь к каталогу, но не более чем ```size-1``` значащих символов и байт ```\0```. Байт ```\0``` должен быть записан в любом случае.

Функция должна сохранять текущий рабочий каталог процесса, то есть текущий рабочий каталог процесса до вызова функции должен совпадать с текущим рабочим каталогом процесса после вызова функции. Файловый дескриптор с номером ```fd``` должен остаться открытым и связанным с тем же (исходным) каталогом.

Из функций и системных вызовов работы с файлами и файловой системой разрешается использовать только ```opendir```, ```closedir```, ```readdir```, ```stat```, ```lstat```, ```fstat```, ```chdir```, ```fchdir```, ```dirfd```. Функции работы со строками и символами разрешается использовать без ограничений. 