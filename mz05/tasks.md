### Problem mz05-1: mz05-1

В аргументах командной строки передаются пути к файлам.

На стандартный поток вывода напечатайте суммарный размер файлов, удовлетворяющих одновременно следующим условиям:

* Файл существует и его размер равен целому числу кибибайт (2^10).
* Файл является регулярным, при этом не является символической ссылкой.
* Файл имеет единственное имя в файловой системе.

### Problem mz05-2: mz05-2

В аргументах командной строки передаются 9-битные восьмеричные числа, соответствующие правам доступа к файлам в UNIX. Каждый аргумент командной строки содержит только одно число. Незначащие нули у восьмеричного числа в могут отсутствовать, а могут и присутствовать. На стандартный поток вывода напечатайте права доступа в rwx-записи. Каждую строку прав доступа выводите на отдельной строке текста.

Для получения строки-результата используйте специально посвященную этому константную строку-шаблон "rwxrwxrwx".

**Examples**

_Input_

```
644 755
```

_Output_

```
rw-r--r--
rwxr-xr-x
```

### Problem mz05-3: mz05-3

Напишите функцию

```c
int
parse_rwx_permissions(const char *str);
```

На вход функции подается строка — права доступа к файлу в формате rwx (9 знаков). Указатель может принимать значение ```NULL```.

Функция должна вернуть соответствующее значение прав доступа, либо -1, если строка не является корректной записью прав доступа. Корректная запись состоит только из символов '-', 'r', 'w', 'x', расположенных в правильном порядке.

Указание: используйте строку-образец "rwxrwxrwx" для разбора входной строки. В функции не должны использоваться константы 3, 8, 9, 10 (даже в виде ```enum``` или ```#define```). Используйте битовые операции.

Поскольку строка-образец является константной, ее длину можно вычислить за константное время на этапе компиляции. В функции может использоваться не более одного вызова ```strlen```.

### Problem mz05-4: mz05-4

В аргументах командной строки передаются пути к файлам.

Если в списке путей к файлам несколько раз встречается один и тот же файл, то оставьте из этих путей один лексикографически максимальный (в смысле сравнения строк) путь. Все оставшиеся (то есть уникальные) пути выведите на стандартный поток вывода в порядке лексикографического возрастания по одному пути на строку.

Если информация о файле по указанному пути недоступна, такой путь игнорируется и вывод не попадает.

Два пути являются путями к одному и тому же файлу, если либо один из них является символической ссылкой на другой, либо оба из них являются символическими ссылками на третий файл, либо файлы являются жесткими ссылками друг друга, либо пути равны.

Например, если файл B является символической ссылкой на файл A, а файл C не связан с ними, то при запуске программы с аргументами:

```
./solution C A B B
```

на стандарный поток вывода должно быть выведено

```
B
C
```

### Problem mz05-5: mz05-5 (хуйня ебучая)

Даны два абсолютных пути к файлам. Постройте кратчайший относительный путь от каталога, в котором находится первый файл, ко второму файлу.

Напишите функцию:

```c
char *relativize_path(const char *path1, const char *path2);
```

И путь ```path1```, и путь ```path2``` являются нормализованными, то есть в пути отсутствуют '/' подряд и последний символ не является '/', за исключением пути "/".

Результатом работы функции является новая строка, содержащая кратчайший по длине символов относительный путь от каталога, в котором содержится первый файл или каталог, ко второму файлу или каталогу.

Обрабатывайте пути как строки. Соответствующие файлы и каталоги не обязаны существовать в файловой системе. Длины путей не ограничены.

Например, если аргументами функции являются строки ```/a/b/c/d``` и ```/a/e/f```, результатом должна быть строка ```../../e/f```.

### Problem mz05-5: mz05-5 old (версия 2022 года)

Напишите функцию:

```c
int copy_file(const char *srcpath, const char *dstpath);
```

```srcpath``` должен быть путем к существующему файлу, доступному на чтение. ```srcpath``` не должен быть каталогом.

Если ```dstpath``` существует и является каталогом, то файл ```srcpath``` должен быть скопирован в каталог ```dstpath```, при этом имя файла в каталоге ```dstpath``` должно совпадать с последней компонентой пути ```srcpath```.

Если ```dstpath``` не существует или не является каталогом, файл ```dstpath``` перезаписывается.

Должна быть предусмотрена защита в случае, когда входной файл совпадает с выходным файлом. В этом случае должно возвращаться 0 и не выполняться никаких действий.

При успешном выполнении функция должна возвращать 0. При ошибке функция должна возвращать -1. Все ресурсы должны быть освобождены.

Для копирования файлов должны должны использоваться системные вызовы ```read```, ```write```. Для временного хранения данных должен использоваться внутренний буфер размером 4 кб.

Права доступа к файлу-копии должны совпадать с правами доступа к исходному файлу.

Символические ссылки специальным образом не обрабатывать.
